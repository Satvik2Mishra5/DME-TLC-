# # with traingular load
# import numpy as np

# # Define the beam parameters
# span = 17  # Span of beam
# A = 3      # Distance to left support from origin
# B = 13     # Distance to right support point from origin

# # Define the point load(s)
# pointLoads = np.array([[6, 0, -90]])  # Format: [location, horizontal force, vertical force]

# # Define the uniformly distributed load parameters
# udl_magnitude = -2  # Magnitude of the uniformly distributed load (per unit length)
# udl_start = 7       # Start position of the uniformly distributed load
# udl_end = 10        # End position of the uniformly distributed load

# # Define the triangular load parameters
# triangular_loads = np.array([[6, -3, 0], [14, 0, -4]])  # Format: [location, horizontal force, vertical force]

# # Initialize data containers
# reactions = np.array([63.0, 0, 27.0])  # Reactions (Va, Ha, Vb)
# shearForce = np.empty([0, span + 1])  # Shear forces at each data point
# bendingMoment = np.empty([0, span + 1])  # Bending moment at each data point

# def reactions_PL(n):
#     xp = pointLoads[n, 0]  # Location of point load
#     fx = pointLoads[n, 1]  # Point load horizontal component magnitude
#     fy = pointLoads[n, 2]  # Point load vertical component magnitude

#     la_p = A - xp  # Lever arm of point load about point A
#     mp = fy * la_p  # Moment generated by point load about A - clockwise moments are positive
#     la_vb = B - A  # Lever arm of vertical reaction at B about point A

#     Vb = mp / la_vb  # Vertical reaction at B
#     Va = -fy - Vb   # Vertical reaction at A
#     Ha = -fx        # Horizontal reaction at A

#     return Va, Vb, Ha

# # Calculate reactions for each point load
# for n, p in enumerate(pointLoads):
#     va, vb, ha = reactions_PL(n)
#     reactions += np.array([va, ha, vb])

# # Calculate reactions due to uniformly distributed load
# udl_length = udl_end - udl_start
# total_udl_force = udl_magnitude * udl_length
# Va_udl = total_udl_force * (B - A) / span
# Vb_udl = total_udl_force * (A) / span
# reactions += np.array([Va_udl, 0, Vb_udl])

# # Calculate reactions due to triangular loads
# for load in triangular_loads:
#     xp = load[0]  # Location of triangular load
#     fx = load[1]  # Triangular load horizontal component magnitude
#     fy = load[2]  # Triangular load vertical component magnitude

#     la_p = A - xp  # Lever arm of triangular load about point A
#     mp = fy * la_p  # Moment generated by triangular load about A
#     la_vb = B - A  # Lever arm of vertical reaction at B about point A

#     Vb = mp / la_vb  # Vertical reaction at B
#     Va = -fy - Vb   # Vertical reaction at A
#     Ha = -fx        # Horizontal reaction at A

#     reactions += np.array([Va, Ha, Vb])

# # Calculate shear and bending moment for each point load
# for n, p in enumerate(pointLoads):
#     xp = p[0]  # Location of point load
#     fy = p[2]  # Point load vertical component magnitude

#     # Initialize arrays to hold shear and bending moment
#     Shear = np.zeros(span + 1)
#     Moment = np.zeros(span + 1)

#     for i, x in enumerate(range(span + 1)):
#         shear = 0
#         moment = 0

#         if x > A:
#             shear += reactions[0]  # Shear from reaction at A
#             moment -= reactions[0] * (x - A)  # Moment from reaction at A

#         if x > B:
#             shear += reactions[2]  # Shear from reaction at B
#             moment -= reactions[2] * (x - B)  # Moment from reaction at B

#         if udl_start <= x <= udl_end:
#             shear += udl_magnitude * (x - udl_start)
#             moment -= udl_magnitude * (x - udl_start) * (x - udl_start) / 2

#         if any(x == load[0] for load in triangular_loads):
#             for load in triangular_loads:
#                 if x == load[0]:
#                     fx = load[1]
#                     fy = load[2]
#                     shear += fy * (x - A) / (B - A)
#                     moment -= fy * (x - A) * (x - A) / (2 * (B - A))

#         if x > xp:
#             shear += fy  # Shear from point load
#             moment -= fy * (x - xp)  # Moment from point load

#         Shear[i] = shear
#         Moment[i] = moment

#     shearForce = np.append(shearForce, [Shear], axis=0)
#     bendingMoment = np.append(bendingMoment, [Moment], axis=0)

# # Find maximum shear force and bending moment
# max_shear_force = np.max(np.abs(shearForce))
# max_bending_moment = np.max(np.abs(bendingMoment))

# print("Maximum Shear Force:", max_shear_force)
# print("Maximum Bending Moment:", max_bending_moment)

# import math
# import numpy as np

# # Define the beam parameters
# span = 17  # Span of beam
# A = 3      # Distance to left support from origin
# B = 13     # Distance to right support point from origin

# # Define the point load(s)
# pointLoads = np.array([[6, 0, -90]])  # Format: [location, horizontal force, vertical force]

# # Define the uniformly distributed load parameters
# udl_magnitude = -2  # Magnitude of the uniformly distributed load (per unit length)
# udl_start = 7       # Start position of the uniformly distributed load
# udl_end = 10        # End position of the uniformly distributed load

# # Initialize data containers
# reactions = np.array([63.0, 0, 27.0])  # Reactions (Va, Ha, Vb)
# shearForce = np.empty([0, span + 1])  # Shear forces at each data point
# bendingMoment = np.empty([0, span + 1])  # Bending moment at each data point

# def reactions_PL(n):
#     xp = pointLoads[n, 0]  # Location of point load
#     fx = pointLoads[n, 1]  # Point load horizontal component magnitude
#     fy = pointLoads[n, 2]  # Point load vertical component magnitude

#     la_p = A - xp  # Lever arm of point load about point A
#     mp = fy * la_p  # Moment generated by point load about A - clockwise moments are positive
#     la_vb = B - A  # Lever arm of vertical reaction at B about point A

#     Vb = mp / la_vb  # Vertical reaction at B
#     Va = -fy - Vb   # Vertical reaction at A
#     Ha = -fx        # Horizontal reaction at A

#     return Va, Vb, Ha

# # Calculate reactions for each point load
# for n, p in enumerate(pointLoads):
#     va, vb, ha = reactions_PL(n)
#     reactions += np.array([va, ha, vb])

# # Calculate reactions due to uniformly distributed load
# udl_length = udl_end - udl_start
# total_udl_force = udl_magnitude * udl_length
# Va_udl = total_udl_force * (B - A) / span
# Vb_udl = total_udl_force * (A) / span
# reactions += np.array([Va_udl, 0, Vb_udl])

# # Calculate shear and bending moment for each point load
# for n, p in enumerate(pointLoads):
#     xp = p[0]  # Location of point load
#     fy = p[2]  # Point load vertical component magnitude

#     # Initialize arrays to hold shear and bending moment
#     Shear = np.zeros(span + 1)
#     Moment = np.zeros(span + 1)

#     for i, x in enumerate(range(span + 1)):
#         shear = 0
#         moment = 0

#         if x > A:
#             shear += reactions[0]  # Shear from reaction at A
#             moment -= reactions[0] * (x - A)  # Moment from reaction at A

#         if x > B:
#             shear += reactions[2]  # Shear from reaction at B
#             moment -= reactions[2] * (x - B)  # Moment from reaction at B

#         if udl_start <= x <= udl_end:
#             shear += udl_magnitude * (x - udl_start)
#             moment -= udl_magnitude * (x - udl_start) * (x - udl_start) / 2

#         if x > xp:
#             shear += fy  # Shear from point load
#             moment -= fy * (x - xp)  # Moment from point load

#         Shear[i] = shear
#         Moment[i] = moment

#     shearForce = np.append(shearForce, [Shear], axis=0)
#     bendingMoment = np.append(bendingMoment, [Moment], axis=0)

# # Find maximum shear force and bending moment
# max_shear_force = np.max(np.abs(shearForce))
# max_bending_moment = np.max(np.abs(bendingMoment))

# print("Maximum Shear Force (N):", max_shear_force)
# print("Maximum Bending Moment (N m):", max_bending_moment)

import math
import numpy as np
import matplotlib.pyplot as plt

# Define the beam parameters
span = 17  # Span of beam
A = 3      # Distance to left support from origin
B = 13     # Distance to right support point from origin

# Define the point load(s)
pointLoads = np.array([[9, 0, -90]])  # Format: [location, horizontal force, vertical force]

# Initialize data containers
shearForce = np.empty([0, span + 1])  # Shear forces at each data point
bendingMoment = np.empty([0, span + 1])  # Bending moment at each data point

# Calculate reaction forces by force and moment balance
def calculate_reactions(pointLoads):
    # Total horizontal and vertical forces
    total_horizontal_force = np.sum(pointLoads[:, 1])
    total_vertical_force = np.sum(pointLoads[:, 2])

    # Moment about support A
    total_moment = 0
    for load in pointLoads:
        total_moment += load[0] * load[2]  # Moment = Force * Distance

    # Solving equations for reaction forces using force and moment balance
    Va = total_vertical_force - (total_horizontal_force * (B - A) / span)
    Vb = total_horizontal_force - Va
    Ha = total_moment / (B - A)

    return Va, Ha, Vb

# Calculate reactions
Va, Ha, Vb = calculate_reactions(pointLoads)
reactions = [Va, Ha, Vb]

shearForce = np.empty([0, span + 1])  # Shear forces at each data point
bendingMoment = np.empty([0, span + 1])  # Bending moment at each data point

def reactions_PL(n):
    xp = pointLoads[n, 0]  # Location of point load
    fx = pointLoads[n, 1]  # Point load horizontal component magnitude
    fy = pointLoads[n, 2]  # Point load vertical component magnitude

    la_p = A - xp  # Lever arm of point load about point A
    mp = fy * la_p  # Moment generated by point load about A - clockwise moments are positive
    la_vb = B - A  # Lever arm of vertical reaction at B about point A

    Vb = mp / la_vb  # Vertical reaction at B
    Va = -fy - Vb   # Vertical reaction at A
    Ha = -fx        # Horizontal reaction at A

    return Va, Vb, Ha

# Calculate reactions for each point load
for n, p in enumerate(pointLoads):
    va, vb, ha = reactions_PL(n)
    reactions += np.array([va, ha, vb])

# Calculate shear and bending moment for each point load
for n, p in enumerate(pointLoads):
    xp = p[0]  # Location of point load
    fy = p[2]  # Point load vertical component magnitude

    # Initialize arrays to hold shear and bending moment
    Shear = np.zeros(span + 1)
    Moment = np.zeros(span + 1)

    for i, x in enumerate(range(span + 1)):
        shear = 0
        moment = 0

        if x > A:
            shear += reactions[0]  # Shear from reaction at A
            moment -= reactions[0] * (x - A)  # Moment from reaction at A

        if x > B:
            shear += reactions[2]  # Shear from reaction at B
            moment -= reactions[2] * (x - B)  # Moment from reaction at B

        if x > xp:
            shear += fy  # Shear from point load
            moment -= fy * (x - xp)  # Moment from point load

        Shear[i] = shear
        Moment[i] = moment

    shearForce = np.append(shearForce, [Shear], axis=0)
    bendingMoment = np.append(bendingMoment, [Moment], axis=0)

# Find maximum shear force and bending moment
max_shear_force = np.max(np.abs(shearForce))
max_bending_moment = np.max(np.abs(bendingMoment))

print("Maximum Shear Force:", max_shear_force)
print("Maximum Bending Moment:", max_bending_moment)

# Define the x-axis data (positions along the beam)
x_positions = np.arange(0, span + 1)

# Plot shear force diagram
plt.figure(figsize=(10, 6))
plt.plot(x_positions, shearForce.T)
plt.title('Shear Force Diagram')
plt.xlabel('Position (ft)')
plt.ylabel('Shear Force (kips)')
plt.grid(True)
plt.show()

# Plot bending moment diagram
plt.figure(figsize=(10, 6))
plt.plot(x_positions, bendingMoment.T)
plt.title('Bending Moment Diagram')
plt.xlabel('Position (ft)')
plt.ylabel('Bending Moment (kip-ft)')
plt.grid(True)
plt.show()

# import math #Math functionality
# import numpy as np #Numpy for working with arrays 

# #INITIALISE DATA CONTAINERS
# reactions = np.array([0.0,0,0]) #Reactions (Va, Ha, Vb) - Defined as array of floats to hold reactions
# shearForce = np.empty([0,len(X)]) #Shear forces at each data point
# bendingMoment = np.empty([0,len(X)]) #Bending moment at each data point

# span = 17 #Span of beam
# A = 3  #Distance to left support
# B = 13 #Distance to right support point
# Loads = np.array([[6,0,-90]])

# def reactions_PL(n):
#   xp = pointLoads[n,0] #Location of point load
#   fx = pointLoads[n,1] #Point load horizontal component magnitude
#   fy = pointLoads[n,2] #Point load vertical component magnitude   

#   la_p = A-xp #Lever arm of point load about point A
#   mp = fy*la_p #Moment generated by point load about A - closkwise moments are positive
#   la_vb = B-A #Lever arm of vertical reaction at B about point A 

#   Vb = mp/la_vb #Vertical reaction at B
#   Va = -fy-Vb #Vertical reaction at A  
#   Ha = -fx#Horizontal reaction at A  

#   return Va, Vb, Ha

# PL_record = np.empty([0,3])

# for n, p in enumerate(pointLoads):
#   va, vb, ha = reactions_PL(n) #Calculate reactions
#   PL_record = np.append(PL_record, [np.array([va, ha, vb])], axis=0) #Store reactions for each point load     

#   #Add reactions to record (superposition)    
#   reactions[0] = reactions[0] + va
#   reactions[1] = reactions[1] + ha
#   reactions[2] = reactions[2] + vb
  
#   def shear_moment_PL(n):
#     xp = pointLoads[n,0] #Location of point load    
#     fy = pointLoads[n,2] #Point load vertical component magnitude     
#     Va = PL_record[n,0] #Vertical reaction at A for this point load    
#     Vb = PL_record[n,2] #Vertical reaction at B for this point load

#     #Cycle through the structure and calculate the shear force and bending moment at each point    
#     Shear = np.zeros(len(X)) #Initialise a container to hold all shear force data for this point load    
#     Moment = np.zeros(len(X)) #Initialise a container to hold all moment force data for this point load    
#     for i, x in enumerate(X):
#         shear = 0 #Initialise the shear force for this data point
#         moment = 0 #Initialise the bending moment for this data point 

#         if x > A:
#         #Calculate shear and moment from reaction at A    
#         shear = shear + Va
#         moment = moment - Va*(x-A)

#         if x > B:
#         #Calculate shear and moment from reaction at B    
#         shear = shear + Vb
#         moment = moment - Vb*(x-B)

#         if x > xp:
#         #Calculate shear and moment from point load    
#         shear = shear + fy
#         moment = moment - fy*(x-xp)

#         #Store shear and moment for this location
#         Shear[i] = shear
#         Moment[i] = moment

#     return Shear, Moment

# for n, p in enumerate(pointLoads):
#   Shear, Moment = shear_moment_PL(n)
#   shearForce = np.append(shearForce, [Shear], axis=0) #Store shear force record for each point load
#   bendingMoment = np.append(bendingMoment, [Moment], axis=0) #Store bending moment record for each point load
  
# import math
# import numpy as np

# # Define the beam parameters
# span = 17  # Span of beam
# A = 3      # Distance to left support
# B = 13     # Distance to right support point

# # Define the point load(s)
# pointLoads = np.array([[10, 0, -500]])  # Format: [location, horizontal force, vertical force]

# # Initialize data containers
# reactions = np.array([0.0, 0, 0])  # Reactions (Va, Ha, Vb)
# shearForce = np.empty([0, span + 1])  # Shear forces at each data point
# bendingMoment = np.empty([0, span + 1])  # Bending moment at each data point

# def reactions_PL(n):
#     xp = pointLoads[n, 0]  # Location of point load
#     fx = pointLoads[n, 1]  # Point load horizontal component magnitude
#     fy = pointLoads[n, 2]  # Point load vertical component magnitude

#     la_p = A - xp  # Lever arm of point load about point A
#     mp = fy * la_p  # Moment generated by point load about A - clockwise moments are positive
#     la_vb = B - A  # Lever arm of vertical reaction at B about point A

#     Vb = mp / la_vb  # Vertical reaction at B
#     Va = -fy - Vb   # Vertical reaction at A
#     Ha = -fx        # Horizontal reaction at A

#     return Va, Vb, Ha

# # Calculate reactions for each point load
# for n, p in enumerate(pointLoads):
#     va, vb, ha = reactions_PL(n)
#     reactions += np.array([va, ha, vb])

# # Print the reactions
# print("Reactions (Va, Ha, Vb):", reactions)

# # Calculate shear and bending moment for each point load
# for n, p in enumerate(pointLoads):
#     xp = p[0]  # Location of point load
#     fy = p[2]  # Point load vertical component magnitude

#     # Initialize arrays to hold shear and bending moment
#     Shear = np.zeros(span + 1)
#     Moment = np.zeros(span + 1)

#     for i, x in enumerate(range(span + 1)):
#         shear = 0
#         moment = 0

#         if x > A:
#             shear += reactions[0]  # Shear from reaction at A
#             moment -= reactions[0] * (x - A)  # Moment from reaction at A

#         if x > B:
#             shear += reactions[2]  # Shear from reaction at B
#             moment -= reactions[2] * (x - B)  # Moment from reaction at B

#         if x > xp:
#             shear += fy  # Shear from point load
#             moment -= fy * (x - xp)  # Moment from point load

#         Shear[i] = shear
#         Moment[i] = moment

#     shearForce = np.append(shearForce, [Shear], axis=0)
#     bendingMoment = np.append(bendingMoment, [Moment], axis=0)

# # Print shear forces and bending moments
# for i in range(len(pointLoads)):
#     print("\nFor Point Load", i+1)
#     print("Shear Force:", shearForce[i])
#     print("Bending Moment:", bendingMoment[i])
